<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Minecraft</title>
        <link
            rel="shortcut icon"
            href="https://www.minecraft.net/content/dam/minecraftnet/franchise/component-library/anniversaryHub/textBannerB/dirtblock.jpg"
            type="image/x-icon"
        />

        <script type="text/javascript">
            "use strict"
            ;(function () {
                const splash = document.createElement("div")

                const originalConsoleLog = console.info
                const logMessages = []

                console.info = function (...args) {
                    if (args.toString().includes("starting")) {
                        setTimeout(() => {
                            splash.id = "booting-splash"
                            splash.innerHTML = `
                        
                        <h1>Launching Minecraft...</h1>
                        <img style="width: 300px; height: auto;" src="https://www.9minecraft.net/wp-content/uploads/2024/01/Armadillo-Mob-Minecraft-Tutorial.gif" />

                        <h3 id="prompt-click">Please press any key to continue...</h3>
                        
                        `
                            document.body.appendChild(splash)
                        }, 0)
                    }

                    logMessages.push(args.toString())
                    originalConsoleLog.apply(console, args)
                }

                window.getLogMessages = function () {
                    return logMessages
                }

                const opts = {}
                var progressPanel = null
                var progressStr1 = null
                var progressStr2 = null
                var progressBarOuter = null
                var progressBarInner = null
                var currentXHR = null

                function makePatternA(domain) {
                    const domainStr = domain
                    return (cid, path) => {
                        return "https://" + domainStr + "/ipfs/" + cid + "/" + path
                    }
                }

                function makePatternB(domain) {
                    const domainStr = domain
                    return (cid, path) => {
                        return "https://" + cid + ".ipfs." + domain + "/" + path
                    }
                }

                const IPFS_GATEWAYS = [
                    makePatternA("gateway.ipfs.io"),
                    makePatternB("4everland.io"),
                    makePatternB("dweb.link"),
                    makePatternA("cloudflare-ipfs.com"),
                    makePatternB("cf-ipfs.com"),
                    makePatternA("w3s.link"),
                    makePatternA("ipfs.eth.aragon.network"),
                    makePatternA("storry.tv"),
                    makePatternB("nftstorage.link"),
                ]

                function tryDecompressDownload(arrayBufferIn) {
                    return new Promise((resolve) => {
                        var ds = new DecompressionStream("gzip")
                        var result = []
                        function fetchStream(reader) {
                            return reader.read().then(function processData({ done, value }) {
                                if (done) {
                                    var ret = new Blob(result)
                                    result = []
                                    return ret.arrayBuffer()
                                }
                                result.push(value)
                                return reader.read().then(processData)
                            })
                        }
                        fetchStream(new Blob([arrayBufferIn]).stream().pipeThrough(ds).getReader())
                            .then((arrayBufferOut) => {
                                resolve(arrayBufferOut)
                            })
                            .catch((err) => {
                                console.error("Could not decompress file!")
                                console.error(err)
                                resolve(null)
                            })
                    })
                }

                function tryDownloadURL(ipfsURL) {
                    const theIpfsURL = ipfsURL
                    return new Promise((resolve) => {
                        var percentDone = -1.0
                        const xhr = (currentXHR = new XMLHttpRequest())
                        xhr.open("GET", ipfsURL)
                        xhr.responseType = "arraybuffer"
                        xhr.addEventListener("progress", (evt) => {
                            updateProgressBar(
                                "Update Available: " +
                                    Math.round(evt.loaded * 0.001) +
                                    " / " +
                                    Math.round(opts.dlSize * 0.001) +
                                    " kB",
                                theIpfsURL,
                                Math.min(evt.loaded / opts.dlSize, 1.0)
                            )
                        })
                        xhr.addEventListener("readystatechange", (evt) => {
                            if (xhr.readyState === XMLHttpRequest.DONE) {
                                updateProgressBar(
                                    "Update Available: " +
                                        Math.round(opts.dlSize * 0.001) +
                                        " / " +
                                        Math.round(opts.dlSize * 0.001) +
                                        " kB",
                                    theIpfsURL,
                                    Math.min(evt.loaded / opts.dlSize, 1.0)
                                )
                                currentXHR = null
                                if (xhr.status === 200) {
                                    resolve(xhr.response)
                                } else {
                                    console.error(
                                        "Got response code " + xhr.status + " for: " + theIpfsURL
                                    )
                                    resolve(null)
                                }
                            }
                        })
                        xhr.addEventListener("error", (evt) => {
                            currentXHR = null
                            console.error("Could not complete request to: " + theIpfsURL)
                            resolve(null)
                        })
                        xhr.addEventListener("load", (evt) => {
                            currentXHR = null
                        })
                        xhr.addEventListener("abort", (evt) => {
                            console.error("Request aborted: " + theIpfsURL)
                            currentXHR = null
                            resolve(null)
                        })
                        xhr.send()
                    })
                }

                function delayProgress(delayMS) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            resolve()
                        }, delayMS)
                    })
                }

                async function tryDownloadClient(ipfsCID, ipfsPath) {
                    var rand = Math.floor(Math.random() * IPFS_GATEWAYS.length)
                    for (var i = 0; i < IPFS_GATEWAYS.length; ++i) {
                        var url = IPFS_GATEWAYS[(rand + i) % IPFS_GATEWAYS.length](
                            ipfsCID,
                            ipfsPath
                        )
                        updateProgressBar(
                            "Update Available: 0 / " + Math.round(opts.dlSize * 0.001) + " kB",
                            url,
                            0.0
                        )
                        try {
                            var j = await tryDownloadURL(url)
                            if (j) {
                                if (opts.gzip) {
                                    try {
                                        updateProgressBar("Extracting...", url, -1)
                                        j = await tryDecompressDownload(j)
                                        if (j) {
                                            return j
                                        } else {
                                            throw "Return value from tryDecompressDownload is undefined"
                                        }
                                    } catch (ex) {
                                        updateProgressBar("Client decompress failed!", url, -1)
                                        console.error("Caught exception during decompress: " + url)
                                        console.error(ex)
                                    }
                                } else {
                                    return j
                                }
                            } else {
                                throw "Return value from tryDownloadURL is undefined"
                            }
                        } catch (ex) {
                            updateProgressBar("Attempting update...", url, 1.0)
                            console.error("Caught exception during download: " + url)
                            console.error(ex)
                        }
                        await delayProgress(1000)
                    }
                    return null
                }

                function loadClientFile(arrayBuffer) {
                    if (progressPanel != null) {
                        progressPanel.remove()
                        progressPanel = null
                        keepClean()
                    }
                    var objURL = URL.createObjectURL(
                        new Blob([arrayBuffer], { type: "text/javascript;charset=utf-8" })
                    )
                    var scriptElement = document.createElement("script")
                    scriptElement.type = "text/javascript"
                    scriptElement.src = objURL
                    document.head.appendChild(scriptElement)
                }

                function initProgressScreen() {
                    if (progressPanel == null) {
                        progressPanel = document.createElement("div")
                        progressPanel.setAttribute(
                            "style",
                            "margin:0px;width:100%;height:100%;display:flex;align-items:center;user-select:none;"
                        )
                        var progressPanelInner = document.createElement("div")
                        progressPanelInner.setAttribute("style", "margin:auto;text-align:center;")

                        var logo = document.createElement("img")
                        logo.setAttribute(
                            "src",
                            "https://www.9minecraft.net/wp-content/uploads/2024/01/Armadillo-Mob-Minecraft-Tutorial.gif"
                        )
                        logo.setAttribute("style", "width: 300px; height: auto;")
                        progressPanelInner.appendChild(logo)

                        progressStr1 = document.createElement("h1")
                        progressPanelInner.appendChild(progressStr1)
                        progressStr2 = document.createElement("h2")
                        progressPanelInner.appendChild(progressStr2)
                        progressBarOuter = document.createElement("div")
                        progressBarOuter.setAttribute(
                            "style",
                            "border:2px solid transparent;width:400px;height:15px;padding:1px;margin:auto;margin-bottom:5px;"
                        )
                        progressBarInner = document.createElement("div")
                        progressBarInner.setAttribute(
                            "style",
                            "background-color:#AA0000;width:0%;height:100%;"
                        )
                        progressBarOuter.appendChild(progressBarInner)
                        progressPanelInner.appendChild(progressBarOuter)

                        progressPanel.appendChild(progressPanelInner)
                        document.getElementById(opts.container).appendChild(progressPanel)
                    }
                }

                function updateProgressScreen(str1) {
                    progressStr1.innerText = str1
                }

                function updateProgressBar(str2, str3, prog) {
                    progressStr2.innerText = str2

                    if (prog < 0) {
                        progressBarInner.style.width = "0%"
                        progressBarOuter.style.border = "2px solid transparent"
                    } else {
                        progressBarInner.style.width =
                            "" + Math.floor(Math.min(prog, 1.0) * 100.0) + "%"
                        progressBarOuter.style.border = "2px solid black"
                    }
                }

                function hasDownloadFailed(cidPath) {
                    if (window.localStorage) {
                        var keyPath = "_eagler_dl_" + cidPath + ".failedAt"
                        var keyValue = window.localStorage.getItem(keyPath)
                        if (keyValue) {
                            try {
                                if (Date.now() - parseInt(keyValue) < 6 * 3600 * 1000) {
                                    // <6 hours = don't retry
                                    return true
                                } else {
                                    window.localStorage.removeItem(keyPath)
                                    return false
                                }
                            } catch (ex) {
                                window.localStorage.removeItem(keyPath)
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                }

                function setDownloadFailed(cidPath) {
                    if (window.localStorage) {
                        window.localStorage.setItem(
                            "_eagler_dl_" + cidPath + ".failedAt",
                            "" + Date.now()
                        )
                    }
                }

                function loadClientFromIndexedDB(fileName) {
                    const reqFileName = fileName
                    return new Promise((resolve) => {
                        const openRequest = window.indexedDB.open("_eagler_loader_cache_v1", 1)
                        openRequest.addEventListener("upgradeneeded", (evt) => {
                            openRequest.result.createObjectStore("file_cache", {
                                keyPath: "fileName",
                            })
                        })
                        openRequest.addEventListener("success", (evt2) => {
                            const db = openRequest.result
                            db.addEventListener("error", (err) => {
                                console.error("Error loading from cache database!")
                                console.error(err)
                            })
                            const transaction = db.transaction(["file_cache"], "readonly")
                            const readRequest = transaction
                                .objectStore("file_cache")
                                .get(reqFileName)
                            var readResult = null
                            readRequest.addEventListener("success", (evt) => {
                                resolve(readRequest.result)
                            })
                            transaction.addEventListener("success", (evt) => {
                                db.close()
                            })
                            transaction.addEventListener("error", (evt) => {
                                db.close()
                                console.error("Failed to load from cache database!")
                                resolve(null)
                            })
                        })
                        openRequest.addEventListener("error", (evt) => {
                            console.error("Failed to open cache database!")
                            console.error(openRequest.error)
                            resolve(null)
                        })
                    })
                }

                function saveClientToIndexedDB(fileData) {
                    return new Promise((resolve) => {
                        const openRequest = window.indexedDB.open("_eagler_loader_cache_v1", 1)
                        openRequest.addEventListener("upgradeneeded", (evt) => {
                            openRequest.result.createObjectStore("file_cache", {
                                keyPath: "fileName",
                            })
                        })
                        openRequest.addEventListener("success", (evt2) => {
                            const db = openRequest.result
                            db.addEventListener("error", (err) => {
                                console.error("Error saving to cache database!")
                                console.error(err)
                            })
                            const transaction = db.transaction(["file_cache"], "readwrite")
                            const writeRequest = transaction.objectStore("file_cache").put(fileData)
                            writeRequest.addEventListener("success", (evt) => {
                                resolve(true)
                            })
                            transaction.addEventListener("success", (evt) => {
                                db.close()
                            })
                            transaction.addEventListener("error", (evt) => {
                                db.close()
                                console.error("Failed to save to cache database!")
                                console.error(evt)
                                resolve(false)
                            })
                        })
                        openRequest.addEventListener("error", (evt) => {
                            console.error("Failed to open cache database!")
                            console.error(openRequest.error)
                            resolve(false)
                        })
                    })
                }

                window.addEventListener("load", async function () {
                    if (!window.__eaglercraftLoaderClient) {
                        console.error("window.__eaglercraftLoaderClient is not defined!")
                        return
                    }

                    opts.container = window.__eaglercraftLoaderClient.container
                    opts.name = window.__eaglercraftLoaderClient.name
                    opts.file = window.__eaglercraftLoaderClient.file
                    opts.cid = window.__eaglercraftLoaderClient.cid
                    opts.path = window.__eaglercraftLoaderClient.path
                    opts.dlSize = window.__eaglercraftLoaderClient.dlSize
                    opts.gzip = window.__eaglercraftLoaderClient.gzip

                    initProgressScreen()
                    updateProgressScreen("Minecraft 1.8.8")
                    updateProgressBar("Loading...", "", -1)

                    if (!window.indexedDB) {
                        console.error("IndexedDB not supported, downloading client directly...")
                        var dl = await tryDownloadClient(opts.cid, opts.path)
                        if (dl) {
                            updateProgressBar("Launching...", "Last fetched: now", -1)
                            await delayProgress(500)
                            loadClientFile(dl)
                        } else {
                            updateProgressScreen("Error: Could not download client!")
                            updateProgressBar(
                                "Please try again later",
                                "Direct download failed!",
                                -1
                            )
                        }
                        return
                    }

                    var clientCIDPath =
                        typeof opts.path !== "string" || opts.path.length === 0
                            ? opts.cid
                            : opts.cid + "/" + opts.path

                    var cachedClient = await loadClientFromIndexedDB(opts.file)
                    var clientDisplayAge = 0

                    if (cachedClient) {
                        clientDisplayAge = Math.floor(
                            (Date.now() - cachedClient.clientCachedAt) / 86400000.0
                        )
                        var hasFailed = hasDownloadFailed(clientCIDPath)
                        if (hasFailed) {
                            hasFailed = confirm(
                                "Failed to update the client!\n\nWould you like to use a backup from " +
                                    clientDisplayAge +
                                    " day(s) ago?"
                            )
                        }
                        if (hasFailed || cachedClient.clientVersionUID === clientCIDPath) {
                            if (hasFailed) {
                                console.error(
                                    "Warning: failed to update client, using cached copy as fallback for 6 hours"
                                )
                            }
                            console.log("Found client file in cache, launching cached client...")
                            updateProgressBar(
                                "Launching...",
                                "Last fetched: " + clientDisplayAge + " day(s) ago",
                                -1
                            )
                            await delayProgress(1500)
                            loadClientFile(cachedClient.clientPayload)
                            return
                        } else {
                            console.log(
                                "Found client file in cache, client is outdated, attempting to update..."
                            )
                        }
                    } else {
                        console.log("Client is not in cache, attempting to download...")
                    }

                    var dl = await tryDownloadClient(opts.cid, opts.path)
                    if (dl) {
                        updateProgressBar("Cacheing...", "Last fetched: now", -1)
                        await saveClientToIndexedDB({
                            fileName: opts.file,
                            clientVersionUID: clientCIDPath,
                            clientCachedAt: Date.now(),
                            clientPayload: dl,
                        })
                        updateProgressBar("Launching...", "Last fetched: now", -1)
                        await delayProgress(500)
                        loadClientFile(dl)
                    } else {
                        if (cachedClient) {
                            setDownloadFailed(clientCIDPath)
                            if (
                                confirm(
                                    "Failed to update the client!\n\nWould you like to use a backup from " +
                                        clientDisplayAge +
                                        " day(s) ago?"
                                )
                            ) {
                                updateProgressBar(
                                    "Launching...",
                                    "Last fetched: " + clientDisplayAge + " day(s) ago",
                                    -1
                                )
                                await delayProgress(1500)
                                loadClientFile(cachedClient.clientPayload)
                                return
                            }
                        }
                        updateProgressScreen("Error: Could not download client!")
                        updateProgressBar("Please try again later", "Client download failed!", -1)
                    }
                })
            })()

            function keepClean() {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "H1") {
                                    node.remove()
                                }
                            })
                        }
                    })
                })

                const observerConfig = { childList: true, subtree: true }
                observer.observe(document.body, observerConfig)
            }

            window.__eaglercraftLoaderClient = {
                container: "game_frame",
                name: "EaglercraftX 1.8",
                file: "net.lax1dude.eaglercraft.v1_8.client",
                cid: "bafybeidpdyddw2ee67zqaqd6qwuojr6xvdwplxatmowccule3mc6rchglu",
                path: "",
                dlSize: 11552190,
                gzip: true,
            }
        </script>
        <style>
            @font-face {
                font-family: launch;
                src: url("assets/launcher-font.otf") format("opentype");
            }

            body {
                font-family: launch, sans-serif;
                background-color: #000;
                color: #fff;
            }

            #booting-splash {
                position: fixed;
                z-index: 100;
                top: 50%;
                left: 50%;
                width: 100%;
                height: 100%;
                transform: translate(-50%, -50%);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                background-color: #000;
                color: #fff;
                font-size: 24px;
                text-align: center;
                pointer-events: none;
            }

            #prompt-click {
                margin-top: 2rem;
                animation: flashing 1s infinite;
            }

            @keyframes flashing {
                0% {
                    opacity: 0.5;
                }
                50% {
                    opacity: 1;
                }
                100% {
                    opacity: 0.5;
                }
            }
        </style>
    </head>
    <body
        style="margin: 0px; width: 100vw; height: 100vh; overflow: hidden;"
        id="game_frame"
    ></body>

    <script>
        let loadedOnce = false
        let pressOnce = false
        function loadOnce() {
            if (!loadedOnce) {
                loadedOnce = true

                if (document.getElementById("prompt-click"))
                    document.getElementById("prompt-click").remove()

                const checkLogs = setInterval(() => {
                    const logs = window.getLogMessages()
                    if (logs.some((log) => log.includes("launching"))) {
                        clearInterval(checkLogs)
                        document.getElementById("booting-splash").remove()
                    }
                }, 1000)
            }
        }

        document.body.onkeydown = () => {
            if (!pressOnce) {
                pressOnce = true
                document.getElementById("game_frame").click()
            }
        }

        document.getElementById("game_frame").addEventListener("click", () => {
            loadOnce()
        })
    </script>
</html>
